VALID_CULTURES = %%VALID_CULTURES%%

build_sources = $(FILES) $(GENERATED_FILES)
build_sources_embed = $(build_sources:%='$(srcdir)/%')

comma__=,
get_resource_name = $(firstword $(subst $(comma__), ,$1))
get_culture =  $(lastword $(subst ., ,$(basename $1)))
is_cultured_resource = $(and $(word 3,$(subst ., ,$1)), $(filter $(VALID_CULTURES),$(lastword $(subst ., ,$(basename $1)))))

build_resx_list = $(foreach res, $(RESOURCES), $(if $(filter %.resx, $(call get_resource_name,$(res))),$(res),))
build_non_culture_resx_list = $(foreach res, $(build_resx_list),$(if $(call is_cultured_resource,$(call get_resource_name,$(res))),,$(res)))
build_non_culture_others_list = $(foreach res, $(filter-out $(build_resx_list),$(RESOURCES)),$(if $(call is_cultured_resource,$(call get_resource_name,$(res))),,$(res)))
build_others_list = $(build_non_culture_others_list)
build_xamlg_list = $(filter %.xaml.g.cs, $(FILES))

# resgen all .resx resources
build_resx_files = $(foreach res, $(build_resx_list), $(call get_resource_name,$(res)))
build_resx_resources = $(build_resx_files:.resx=.resources)

# embed resources for the main assembly
build_resx_resources_hack = $(subst .resx,.resources, $(build_non_culture_resx_list))
build_resx_resources_embed = $(build_resx_resources_hack:%='-resource:%')
build_others_files = $(foreach res, $(build_others_list),$(call get_resource_name,$(res)))
build_others_resources = $(build_others_files)
build_others_resources_embed = $(build_others_list:%='-resource:$(srcdir)/%')

build_resources = $(build_resx_resources) $(build_others_resources)
build_resources_embed = $(build_resx_resources_embed) $(build_others_resources_embed)

build_references_ref = $(foreach ref, $(REFERENCES), $(if $(filter -pkg:%, $(ref)), $(ref), $(if $(filter -r:%, $(ref)), $(ref), -r:$(ref))))
build_references_ref += $(foreach ref, $(DLL_REFERENCES), -r:$(ref))
build_references_ref += $(foreach ref, $(PROJECT_REFERENCES), -r:$(ref))

EXTRA_DIST += $(build_sources) $(build_resx_files) $(build_others_files) $(ASSEMBLY_WRAPPER_IN) $(EXTRAS) $(DATA_FILES) $(build_culture_res_files)
CLEANFILES += $(ASSEMBLY) $(ASSEMBLY).mdb $(BINARIES) $(build_resx_resources) $(build_satellite_assembly_list)
DISTCLEANFILES = $(GENERATED_FILES) $(pc_files) $(BUILD_DIR)/*

pkglib_SCRIPTS = $(ASSEMBLY)
bin_SCRIPTS = $(BINARIES)

%%DEPLOY_DIRS%%

# macros

# $(call emit-deploy-target,deploy-variable-name)
define emit-deploy-target
$($1): $($1_SOURCE)
	mkdir -p $$(dir $($1))
	cp '$$<' '$$@'
endef

# $(call emit-deploy-wrapper,wrapper-variable-name,wrapper-sourcefile,x)
# assumes that for a wrapper foo.pc its source template is foo.pc.in
# if $3 is non-empty then wrapper is marked exec
define emit-deploy-wrapper
$($1): $2 %%CONFIG_MAKE_DEP%%
	mkdir -p '$$(@D)'
	cp '$$<' '$$@'
	$(if $3,chmod +x '$$@')
%%WRAPPER_SED%%
endef

# generating satellite assemblies

culture_resources = $(foreach res, $(RESOURCES), $(if $(call is_cultured_resource,$(call get_resource_name, $(res))),$(res)))
cultures = $(sort $(foreach res, $(culture_resources), $(call get_culture,$(call get_resource_name,$(res)))))
culture_resource_dependencies = $(BUILD_DIR)/$1/$(SATELLITE_ASSEMBLY_NAME): $(subst .resx,.resources,$2)
culture_resource_commandlines = cmd_line_satellite_$1 += '/embed:$(subst .resx,.resources,$2)'
build_satellite_assembly_list = $(cultures:%=$(BUILD_DIR)/%/$(SATELLITE_ASSEMBLY_NAME))
build_culture_res_files = $(foreach res, $(culture_resources),$(call get_resource_name,$(res)))

$(eval $(foreach res, $(culture_resources), $(eval $(call culture_resource_dependencies,$(call get_culture,$(call get_resource_name,$(res))),$(call get_resource_name,$(res))))))
$(eval $(foreach res, $(culture_resources), $(eval $(call culture_resource_commandlines,$(call get_culture,$(call get_resource_name,$(res))),$(res)))))

$(build_satellite_assembly_list): $(BUILD_DIR)/%/$(SATELLITE_ASSEMBLY_NAME):
	mkdir -p '$(@D)'
	$(AL) -out:'$@' -culture:$* -t:lib $(cmd_line_satellite_$*)
